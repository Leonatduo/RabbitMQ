# RabbitMQ 交换机（Exchange）核心概念

## 3.1 交换机类型

### 基础模型对比
| 模型          | 消息流向                     |
|---------------|-----------------------------|
| 无交换机      | Publisher → Queue → Consumer |
| 有交换机      | Publisher → Exchange → Queue → Consumer |

### 核心角色
- **Publisher**  
  消息生产者，不再直接发送到队列，而是发送到交换机
- **Exchange**  
  - 接收生产者消息  
  - 根据规则路由消息（转发/丢弃）  
  - **无存储能力**（无绑定队列时消息丢失）
- **Queue**  
  必须绑定交换机，负责缓存消息
- **Consumer**  
  行为不变，仍通过订阅队列消费消息

### 交换机类型对比
| 类型       | 路由规则                          | 典型场景             |
|------------|-----------------------------------|----------------------|
| `Fanout`   | 广播到所有绑定队列                | 通知全体系统         |
| `Direct`   | 精确匹配 `RoutingKey`             | 订单分类处理         |
| `Topic`    | 通配符匹配 `RoutingKey`           | 多层级消息分类       |
| `Headers`  | 基于消息头匹配（极少使用）        | 特殊过滤需求         |

---

## 3.2 Fanout交换机

Fanout，英文翻译是扇出，在MQ中叫广播更合适。

在广播模式下，消息发送流程是这样的：

1. 可以有多个队列
2. 每个队列都要绑定到Exchange（交换机）
3. 生产者发送的消息，只能发送到交换机
4. 交换机把消息发送给绑定过的所有队列
5. 订阅队列的消费者都能拿到消息

### 总结

交换机的作用是什么？

- 接收publisher发送的消息
- 将消息按照规则路由到与之绑定的队列
- 不能缓存消息，路由失败，消息丢失
- FanoutExchange会将消息路由到每个绑定的队列

---

## 3.3 Direct交换机

在Fanout模式中，一条消息会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。

在Direct模型下：

- 队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）
- 消息的发送方向Exchange发送消息时，也必须指定消息的RoutingKey
- Exchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断
- 只有队列的Routingkey与消息的Routing key完全一致，才会接收到消息

---

## 3.4 Topic交换机

### 3.4.1 说明

Topic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定BindingKey的时候使用通配符！

BindingKey一般都是有一个或多个单词组成，多个单词之间以"."分割，例如：item.insert

#### 通配符规则：

- `#`：匹配一个或多个词
- `*`：匹配不多不少恰好1个词

#### 举例：

- `item.#`：能够匹配item.spu.insert 或者 item.spu
- `item.*`：只能匹配item.spu
