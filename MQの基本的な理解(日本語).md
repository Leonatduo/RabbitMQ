# 1. MQ入門

## 1.1 同期呼び出し

### 現在の実装方法
OpenFeignを使用した同期呼び出しフロー（残高支払いを例として）：
1. 支払いサービス → ユーザーサービス（残高控除）
2. 支払いサービスの支払い伝票状態更新
3. 支払いサービス → 取引サービス（注文状態更新）

### 同期呼び出しの3大問題点

#### 1. 拡張性の低さ
- 新規要件例：
  - 支払い成功SMS通知
  - ポイント/コイン付与
- 発生する問題：
  - 支払いロジックの頻繁な変更
  - オープン・クローズド原則違反
  - コードの肥大化

#### 2. パフォーマンス低下
- 同期ブロッキング特性：
  - 呼び出し元は応答を待機必須
- パフォーマンス計算式：
  - 総時間 = ∑各マイクロサービス呼び出し時間
  - 例：6回の50ms呼び出し → 300ms総時間

#### 3. 連鎖的失敗
- 典型的なシナリオ：
  - 取引サービス/通知サービス障害 → 全トランザクションロールバック
- 矛盾点：
  - 完了した残高控除はロールバックすべきでない
  - コア業務と補助業務は分離すべき

### 同期呼び出し問題まとめ
- ✅ 拡張性の低さ
- ✅ パフォーマンスボトルネック
- ✅ 連鎖的障害リスク

---

## 1.2 非同期呼び出し

### コアコンポーネント
1. **メッセージ送信者**：元の呼び出し元
2. **メッセージBroker**：メッセージ中継局（例：RabbitMQ）
3. **メッセージ受信者**：元のサービス提供者

### ワークフロー
1. 送信者 → Brokerへメッセージ配信
2. 受信者がBrokerからメッセージ購読
3. 完全に分離された通信モード

### 支払い業務改造例
- **同期部分**：
  - 残高控除
  - 支払い伝票更新
- **非同期部分**：
  - 注文状態更新 → メッセージキュー
  - SMS通知 → メッセージキュー
  - ポイント付与 → メッセージキュー

### 非同期呼び出しの利点
| 利点 | 説明 |
|------|------|
| 低結合 | サービス間の直接依存なし |
| 高性能 | 総時間≈コア業務時間（例：100ms） |
| 高拡張性 | 新規購読者の追加でメインフロー変更不要 |
| 障害分離 | 補助サービス障害がコア業務に影響しない |

### 非同期呼び出しの欠点
⚠️ **Broker依存**：  
- 信頼性の高い要求  
- パフォーマンスボトルネックリスク  

⚠️ **アーキテクチャ複雑さ**：  
- デバッグ・メンテナンス難易度上昇  
- メッセージ一貫性の課題  
