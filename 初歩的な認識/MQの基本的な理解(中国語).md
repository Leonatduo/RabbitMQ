# 1. 初识MQ

## 1.1 同步调用

### 当前实现方式
基于OpenFeign的同步调用流程（以余额支付为例）：
1. 支付服务 → 用户服务（余额扣减）
2. 支付服务更新支付流水单状态
3. 支付服务 → 交易服务（更新订单状态）

### 同步调用的三大问题

#### 1. 拓展性差
- 新增需求示例：
  - 支付成功短信通知
  - 积分/金币奖励
- 导致问题：
  - 支付逻辑频繁变更
  - 违反开闭原则
  - 代码臃肿化

#### 2. 性能下降
- 同步阻塞特性：
  - 调用方必须等待被调用方响应
- 性能计算公式：
  - 总耗时 = ∑各微服务调用耗时
  - 示例：6个50ms调用 → 300ms总耗时

#### 3. 级联失败
- 典型场景：
  - 交易服务/通知服务故障 → 整个事务回滚
- 矛盾点：
  - 已完成的余额扣减不应回滚
  - 核心业务应与辅助业务解耦

### 同步调用问题总结
- ✅ 拓展性差
- ✅ 性能瓶颈
- ✅ 级联故障风险

---

## 1.2 异步调用

### 核心组件
1. **消息发送者**：原调用方
2. **消息Broker**：消息中转站（如RabbitMQ）
3. **消息接收者**：原服务提供方

### 工作流程
1. 发送者 → Broker投递消息
2. 接收者从Broker订阅消息
3. 完全解耦的通信模式

### 支付业务改造示例
- **同步部分**：
  - 余额扣减
  - 支付流水更新
- **异步部分**：
  - 订单状态更新 → 消息队列
  - 短信通知 → 消息队列
  - 积分奖励 → 消息队列

### 异步调用优势
| 优势 | 说明 |
|------|------|
| 低耦合 | 服务间无直接依赖 |
| 高性能 | 总耗时≈核心业务耗时（示例：100ms） |
| 高扩展 | 新增订阅者无需修改主流程 |
| 故障隔离 | 辅助服务故障不影响核心业务 |

### 异步调用缺点
⚠️ **Broker依赖**：  
- 可靠性要求高  
- 性能瓶颈风险  

⚠️ **架构复杂度**：  
- 调试维护难度增加  
- 消息一致性挑战  

# 1.3 消息队列对比

消息Broker，目前常见的实现方案就是消息队列（MessageQueue），简称为MQ。

## 常见MQ实现
- ActiveMQ
- RabbitMQ
- RocketMQ
- Kafka

## 对比维度

| 维度         | 推荐方案                          |
|--------------|----------------------------------|
| 可用性       | Kafka、RocketMQ、RabbitMQ        |
| 可靠性       | RabbitMQ、RocketMQ               |
| 吞吐能力     | RocketMQ、Kafka                  |
| 消息低延迟   | RabbitMQ、Kafka                  |
